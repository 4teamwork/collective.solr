Index: collective.solr/trunk/collective/solr/parser.py
===================================================================
--- collective.solr/trunk/collective/solr/parser.py	(revision 13431)
+++ collective.solr/trunk/collective/solr/parser.py	(revision 13432)
@@ -99,72 +99,86 @@
         return lst
 
 
-# Handlers, register for event and element names, like ('end','int')
-# lst is dict, arr is list, bool, date, float, int, str are the same as python
-# last has name variables, arr does not
-# response - the whole thing (dict)
-# name=responseHeader is special
-# result - create result obj
-# doc - create SolrFlare (dict)
+# Traditional parser style
+
+class Response(dict):
+    def getHeaders(self):
+        return self.get('responseHeader',{})
+
+    def getResults(self):
+        return self.get('response',[])
+
+class Result(list):
+    def __init__(self, name, numFound, start):
+        self.name = name
+        self.numFound = int(numFound)
+        self.start = int(start)
+
+_marker = []
+class Flare(dict):
+    # Look up attributes in dict
+    def __getattr__(self, name):
+        res = self.get(name, _marker)
+        if res is not _marker:
+            return res
+        else:
+            raise AttributeError, name
+
+def add_node(value, elem, stack):
+    if elem.get('name', None) is not None:
+        stack[-1][elem.get('name')] = value
+    else:
+        stack[-1].append(value)
 
 def pop_stack(elem, stack):
     stack.pop()
 
 def handle_start_response(elem, stack):
-    response = {} # Create new Response obj
+    response = Response() # Create new Response obj
     stack.append(response)
 
 def handle_start_lst(elem, stack):
     lst = {}
-    if elem.get('name', None) is not None:
-        stack[-1][elem.get('name')] = lst
-    else:
-        stack[-1].append(lst)
+    add_node(lst, elem, stack)
     stack.append(lst)
 
 def handle_start_result(elem, stack):
-    # Set special attributes like numfound and start
-    result = [] # Create result object wtih special attributes
-    stack[-1][elem.get('name')] = result
+    result = Result(elem.get('name',None), elem.get('numFound',None), elem.get('start',None))
+    add_node(result, elem, stack)
     stack.append(result)
 
 def handle_start_arr(elem, stack):
     # Set special attributes like numfound and start
     arr = []
-    if elem.get('name', None) is not None:
-        stack[-1][elem.get('name')] = arr
-    else:
-        stack[-1].append(arr)
+    add_node(arr, elem, stack)
     stack.append(arr)
 
 def handle_start_doc(elem, stack):
-    doc = {} # Create SolrFlare
-    stack[-1].append(doc)
+    doc = Flare()
+    add_node(doc, elem, stack)
     stack.append(doc)
 
 def handle_literal(func):
     def handle(elem, stack):
-        if elem.get('name', None) is not None:
-            stack[-1][elem.get('name')] = func(elem)
-        else:
-            stack[-1].append(func(elem))
+        value = func(elem)
+        add_node(value, elem, stack)
     return handle
 
 handlers = {
-    ('start','response'): handle_start_response,
-    ('start','lst'): handle_start_lst,
-    ('end'  ,'lst'): pop_stack,
-    ('start','arr'): handle_start_arr,
-    ('end'  ,'arr'): pop_stack,
-    ('start','result'): handle_start_result,
-    ('end'  ,'result'): pop_stack,
-    ('start','doc'): handle_start_doc,
-    ('end'  ,'doc'): pop_stack,
-    ('end','int'):   handle_literal(lambda x: int(x.text)),
-    ('end','float'): handle_literal(lambda x: float(x.text)),
-    ('end','bool'):  handle_literal(lambda x: x.text == 'true'),
-    ('end','str'):   handle_literal(lambda x: x.text or ''),
-    ('end','date'):  handle_literal(lambda x: DateTime(x.text)),
+    ('start','response'): handle_start_response, # No end handler to leave it in stack
+    ('start','lst'):      handle_start_lst,
+    ('end'  ,'lst'):      pop_stack,
+    ('start','arr'):      handle_start_arr,
+    ('end'  ,'arr'):      pop_stack,
+    ('start','result'):   handle_start_result,
+    ('end'  ,'result'):   pop_stack,
+    ('start','doc'):      handle_start_doc,
+    ('end'  ,'doc'):      pop_stack,
+    ('end'  ,'int'):      handle_literal(lambda x: int(x.text)),
+    ('end'  ,'float'):    handle_literal(lambda x: float(x.text)),
+    ('end'  ,'bool'):     handle_literal(lambda x: x.text == 'true'),
+    ('end'  ,'str'):      handle_literal(lambda x: x.text or ''),
+    ('end'  ,'date'):     handle_literal(lambda x: DateTime(x.text)),
 }
 
 def parse2(data):
Index: collective.solr/trunk/collective/solr/tests.py
===================================================================
--- collective.solr/trunk/collective/solr/tests.py	(revision 13431)
+++ collective.solr/trunk/collective/solr/tests.py	(revision 13432)
@@ -358,13 +358,71 @@
         self.assertEqual(counts['facet_fields']['cat']['software'], 1)
         self.assertEqual(counts['facet_fields']['inStock']['true'], 1)
 
-    def testParse2(self):
+    def testParseFacetSearchResults2(self):
         response = parse2(FACET_XML_RESPONSE)
         self.failUnless(response)
+        results = response.getResults()
+        self.assertEqual(len(results), 0)
+        headers = response.getHeaders()
+        self.assertEqual(type(headers), type({}))
+        self.assertEqual(headers['status'], 0)
+        self.assertEqual(headers['QTime'], 1)
+        self.assertEqual(headers['params']['facet.limit'], '-1')
+        self.assertEqual(headers['params']['rows'], '0')
+        self.assertEqual(headers['params']['facet'], 'true')
+        self.assertEqual(headers['params']['facet.field'], ['cat', 'inStock'])
+        self.assertEqual(headers['params']['indent'], '10')
+        self.assertEqual(headers['params']['q'], 'solr')
+        counts = response['facet_counts']
+        self.assertEqual(type(counts), type({}))
+        self.assertEqual(counts['facet_queries'], {})
+        self.assertEqual(counts['facet_fields']['cat']['electronics'], 0)
+        self.assertEqual(counts['facet_fields']['cat']['monitor'], 0)
+        self.assertEqual(counts['facet_fields']['cat']['search'], 1)
+        self.assertEqual(counts['facet_fields']['cat']['software'], 1)
+        self.assertEqual(counts['facet_fields']['inStock']['true'], 1)
+
+    def testParseComplexSearchResults2(self):
         response = parse2(COMPLEX_XML_RESPONSE)
         self.failUnless(response)
+        results = response.getResults()
+        self.assertEqual(len(results), 2)
+        first = results[0]
+        self.assertEqual(first.cat, ['software', 'search'])
+        self.assertEqual(len(first.features), 7)
+        self.assertEqual([type(x).__name__ for x in first.features], ['str'] * 6 + ['unicode'])
+        self.assertEqual(first.id, 'SOLR1000')
+        self.assertEqual(first.inStock, True)
+        self.assertEqual(first.incubationdate_dt, DateTime('2006/01/17 GMT'))
+        self.assertEqual(first.manu, 'Apache Software Foundation')
+        self.assertEqual(first.popularity, 10)
+        self.assertEqual(first.price, 0.0)
+        headers = response.getHeaders()
+        self.assertEqual(headers['status'], 0)
+        self.assertEqual(headers['QTime'], 0)
+        self.assertEqual(headers['params']['indent'], 'on')
+        self.assertEqual(headers['params']['rows'], '10')
+        self.assertEqual(headers['params']['start'], '0')
+        self.assertEqual(headers['params']['q'], 'id:[* TO *]')
+        self.assertEqual(headers['params']['version'], '2.2')
+
+    def testParseSearchResponse2(self):
         response = parse2(SEARCH_RESPONSE.split('\n\n', 1)[1])
-        self.failUnless(response)
+        results = response.getResults()
+        match = results[0]
+        self.assertEqual(len(results), 1)
+        self.assertEqual(match.id, '500')
+        self.assertEqual(match.name, 'python test doc')
+        self.assertEqual(match.popularity, 0)
+        self.assertEqual(match.sku, '500')
+        self.assertEqual(match.timestamp, DateTime('2008-02-29 16:11:46.998 GMT'))
+        headers = response.getHeaders()
+        self.assertEqual(headers['status'], 0)
+        self.assertEqual(headers['QTime'], 0)
+        self.assertEqual(headers['params']['wt'], 'xml')
+        self.assertEqual(headers['params']['indent'], 'on')
+        self.assertEqual(headers['params']['rows'], '10')
+        self.assertEqual(headers['params']['q'], 'id:[* TO *]')
 
 
 def test_suite():
