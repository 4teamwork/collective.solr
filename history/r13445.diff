Index: collective.solr/trunk/collective/solr/schema.xml
===================================================================
--- collective.solr/trunk/collective/solr/schema.xml	(revision 13444)
+++ collective.solr/trunk/collective/solr/schema.xml	(revision 13445)
@@ -1,111 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<schema name="example" version="1.1">
-  <types>
-    <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="integer" class="solr.IntField" omitNorms="true"/>
-    <fieldType name="long" class="solr.LongField" omitNorms="true"/>
-    <fieldType name="float" class="solr.FloatField" omitNorms="true"/>
-    <fieldType name="double" class="solr.DoubleField" omitNorms="true"/>
-    <fieldType name="sint" class="solr.SortableIntField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="slong" class="solr.SortableLongField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="sfloat" class="solr.SortableFloatField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="sdouble" class="solr.SortableDoubleField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="date" class="solr.DateField" sortMissingLast="true" omitNorms="true"/>
-    <fieldType name="random" class="solr.RandomSortField" indexed="true"/>
-    <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="text" class="solr.TextField" positionIncrementGap="100">
-      <analyzer type="index">
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.EnglishPorterFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-      <analyzer type="query">
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.EnglishPorterFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="textTight" class="solr.TextField" positionIncrementGap="100">
-      <analyzer>
-        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
-        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
-        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
-        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.EnglishPorterFilterFactory" protected="protwords.txt"/>
-        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
-      </analyzer>
-    </fieldType>
-    <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
-      <analyzer>
-        <tokenizer class="solr.KeywordTokenizerFactory"/>
-        <filter class="solr.LowerCaseFilterFactory"/>
-        <filter class="solr.TrimFilterFactory"/>
-        <filter class="solr.PatternReplaceFilterFactory" pattern="([^a-z])" replacement="" replace="all"/>
-      </analyzer>
-    </fieldType>
-    <fieldtype name="ignored" stored="false" indexed="false" class="solr.StrField"/> 
- </types>
- <fields>
-   <field name="id" type="string" indexed="true" stored="true" required="true"/> 
-   <field name="sku" type="textTight" indexed="true" stored="true" omitNorms="true"/>
-   <field name="name" type="text" indexed="true" stored="true"/>
-   <field name="nameSort" type="string" indexed="true" stored="false"/>
-   <field name="alphaNameSort" type="alphaOnlySort" indexed="true" stored="false"/>
-   <field name="manu" type="text" indexed="true" stored="true" omitNorms="true"/>
-   <field name="cat" type="text_ws" indexed="true" stored="true" multiValued="true" omitNorms="true" termVectors="true"/>
-   <field name="features" type="text" indexed="true" stored="true" multiValued="true"/>
-   <field name="includes" type="text" indexed="true" stored="true"/>
-   <field name="weight" type="sfloat" indexed="true" stored="true"/>
-   <field name="price" type="sfloat" indexed="true" stored="true"/>
-   <field name="popularity" type="sint" indexed="true" stored="true" default="0"/>
-   <field name="inStock" type="boolean" indexed="true" stored="true"/>
-   <field name="word" type="string" indexed="true" stored="true"/>
-   <field name="text" type="text" indexed="true" stored="false" multiValued="true"/>
-   <field name="manu_exact" type="string" indexed="true" stored="false"/>
-   <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
-
-   <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
-        will be used if the name matches any of the patterns.
-        RESTRICTION: the glob-like pattern in the name attribute must have
-        a "*" only at the start or the end.
-        EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
-        Longer patterns will be matched first.  if equal size patterns
-        both match, the first appearing in the schema will be used.  -->
-   <dynamicField name="*_i" type="sint" indexed="true" stored="true"/>
-   <dynamicField name="*_s" type="string" indexed="true" stored="true"/>
-   <dynamicField name="*_l" type="slong" indexed="true" stored="true"/>
-   <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
-   <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
-   <dynamicField name="*_f" type="sfloat" indexed="true" stored="true"/>
-   <dynamicField name="*_d" type="sdouble" indexed="true" stored="true"/>
-   <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
-
-   <dynamicField name="random*" type="random"/>
- </fields>
- <uniqueKey>id</uniqueKey>
- <defaultSearchField>text</defaultSearchField>
- <solrQueryParser defaultOperator="OR"/>
-   <copyField source="id" dest="sku"/>
-   <copyField source="incubationdate_dt" dest="incubationdate_s"/>
-   <copyField source="cat" dest="text"/>
-   <copyField source="name" dest="text"/>
-   <copyField source="name" dest="nameSort"/>
-   <copyField source="name" dest="alphaNameSort"/>
-   <copyField source="manu" dest="text"/>
-   <copyField source="features" dest="text"/>
-   <copyField source="includes" dest="text"/>
-   <copyField source="manu" dest="manu_exact"/>
-</schema>
\ No newline at end of file
Index: collective.solr/trunk/collective/solr/tests.py
===================================================================
--- collective.solr/trunk/collective/solr/tests.py	(revision 13444)
+++ collective.solr/trunk/collective/solr/tests.py	(revision 13445)
@@ -1,446 +0,0 @@
-# -*- coding: utf-8 -*-
-
-from os.path import dirname, join
-
-from unittest import TestCase, TestSuite, makeSuite, main
-from StringIO import StringIO
-from DateTime import DateTime
-from httplib import HTTPConnection
-
-import collective.solr.tests
-from collective.solr.solr import SolrConnection
-from collective.solr.parser import SolrResponse
-from collective.solr.parser import parse2
-from collective.solr.parser import parseConfig
-
-
-ADD_REQUEST = """POST /solr/update HTTP/1.1\r
-Host: localhost\r
-Accept-Encoding: identity\r
-Content-Length: 92\r
-Content-Type: text/xml; charset=utf-8\r
-\r
-<add><doc><field name="id">500</field><field name="name">python test doc</field></doc></add>"""
-
-
-ADD_RESPONSE = """HTTP/1.1 200 OK
-Content-Type: text/xml; charset=utf-8
-Content-Length: 147
-Server: Jetty(6.1.3)
-
-<?xml version="1.0" encoding="UTF-8"?>
-<response>
-<lst name="responseHeader"><int name="status">0</int><int name="QTime">4</int></lst>
-</response>
-
-"""
-
-
-COMMIT_REQUEST = """POST /solr/update HTTP/1.1\r
-Host: localhost\r
-Accept-Encoding: identity\r
-Content-Length: 9\r
-Content-Type: text/xml; charset=utf-8\r
-\r
-<commit/>"""
-
-COMMIT_RESPONSE = """HTTP/1.1 200 OK
-Content-Type: text/xml; charset=utf-8
-Content-Length: 148
-Server: Jetty(6.1.3)
-
-<?xml version="1.0" encoding="UTF-8"?>
-<response>
-<lst name="responseHeader"><int name="status">0</int><int name="QTime">55</int></lst>
-</response>
-
-"""
-
-SEARCH_REQUEST = """POST /solr/select HTTP/1.1\r
-Host: localhost\r
-Accept-Encoding: identity\r
-Content-Length: 48\r
-Content-Type: application/x-www-form-urlencoded; charset=utf-8\r
-\r
-q=id%3A%5B%2A+TO+%2A%5D&rows=10&wt=xml&indent=on"""
-
-
-SEARCH_RESPONSE = """HTTP/1.1 200 OK
-Content-Type: text/xml; charset=utf-8
-Content-Length: 560
-Server: Jetty(6.1.3)
-
-<?xml version="1.0" encoding="UTF-8"?>
-<response>
-
-<lst name="responseHeader">
- <int name="status">0</int>
- <int name="QTime">0</int>
- <lst name="params">
-  <str name="wt">xml</str>
-  <str name="indent">on</str>
-  <str name="rows">10</str>
-  <str name="q">id:[* TO *]</str>
- </lst>
-</lst>
-<result name="response" numFound="1" start="0">
- <doc>
-  <str name="id">500</str>
-  <str name="name">python test doc</str>
-  <int name="popularity">0</int>
-  <str name="sku">500</str>
-  <date name="timestamp">2008-02-29T16:11:46.998Z</date>
- </doc>
-</result>
-</response>
-
-"""
-
-
-DELETE_REQUEST = """POST /solr/update HTTP/1.1\r
-Host: localhost\r
-Accept-Encoding: identity\r
-Content-Length: 29\r
-Content-Type: text/xml; charset=utf-8\r
-\r
-<delete><id>500</id></delete>"""
-
-DELETE_RESPONSE = """HTTP/1.1 200 OK
-Content-Type: text/xml; charset=utf-8
-Content-Length: 147
-Server: Jetty(6.1.3)
-
-<?xml version="1.0" encoding="UTF-8"?>
-<response>
-<lst name="responseHeader"><int name="status">0</int><int name="QTime">0</int></lst>
-</response>
-
-"""
-
-
-COMPLEX_XML_RESPONSE = """<?xml version="1.0" encoding="UTF-8"?>
-<response>
-
-<lst name="responseHeader">
- <int name="status">0</int>
- <int name="QTime">0</int>
- <lst name="params">
-  <str name="indent">on</str>
-  <str name="rows">10</str>
-
-  <str name="start">0</str>
-  <str name="q">id:[* TO *]</str>
-  <str name="version">2.2</str>
- </lst>
-</lst>
-<result name="response" numFound="2" start="0">
- <doc>
-  <arr name="cat"><str>software</str><str>search</str></arr>
-
-  <arr name="features"><str>Advanced Full-Text Search Capabilities using Lucene</str><str>Optimizied for High Volume Web Traffic</str><str>Standards Based Open Interfaces - XML and HTTP</str>
-	<str>Comprehensive HTML Administration Interfaces</str><str>Scalability - Efficient Replication to other Solr Search Servers</str><str>Flexible and Adaptable with XML configuration and Schema</str><str>Good unicode support: héllo (hello with an accent over the e)</str></arr>
-  <str name="id">SOLR1000</str>
-  <bool name="inStock">true</bool>
-
-  <date name="incubationdate_dt">2006-01-17T00:00:00.000Z</date>
-  <str name="manu">Apache Software Foundation</str>
-  <str name="name">Solr, the Enterprise Search Server</str>
-  <int name="popularity">10</int>
-  <float name="price">0.0</float>
-  <str name="sku">SOLR1000</str>
-
-  <date name="timestamp">2008-03-01T00:13:11.767Z</date>
- </doc>
- <doc>
-  <arr name="cat"><str>electronics</str><str>monitor</str></arr>
-  <arr name="features"><str>30" TFT active matrix LCD, 2560 x 1600, .25mm dot pitch, 700:1 contrast</str></arr>
-  <str name="id">3007WFP</str>
-
-  <bool name="inStock">true</bool>
-  <str name="includes">USB cable</str>
-  <str name="manu">Dell, Inc.</str>
-  <str name="name">Dell Widescreen UltraSharp 3007WFP</str>
-  <int name="popularity">6</int>
-  <float name="price">2199.0</float>
-
-  <str name="sku">3007WFP</str>
-  <date name="timestamp">2008-03-01T00:13:11.814Z</date>
-  <float name="weight">401.6</float>
- </doc>
-</result>
-</response>
-"""
-
-FACET_XML_RESPONSE = """<?xml version="1.0" encoding="UTF-8"?>
-<response>
-
-<lst name="responseHeader">
- <int name="status">0</int>
- <int name="QTime">1</int>
- <lst name="params">
-  <str name="facet.limit">-1</str>
-  <str name="rows">0</str>
-
-  <str name="facet">true</str>
-  <arr name="facet.field">
-	<str>cat</str>
-	<str>inStock</str>
-  </arr>
-  <str name="indent">10</str>
-  <str name="q">solr</str>
-
- </lst>
-</lst>
-<result name="response" numFound="1" start="0"/>
-<lst name="facet_counts">
- <lst name="facet_queries"/>
- <lst name="facet_fields">
-  <lst name="cat">
-	<int name="electronics">0</int>
-	<int name="monitor">0</int>
-
-	<int name="search">1</int>
-	<int name="software">1</int>
-  </lst>
-  <lst name="inStock">
-	<int name="true">1</int>
-  </lst>
- </lst>
-
-</lst>
-</response>
-"""
-
-class TestSolr(TestCase):
-
-    def fakehttp(self, solrconn, fakedata, output):
-        class FakeSocket(StringIO):
-            def sendall(self, str): output.append(str)
-            def makefile(self, mode, name): return self
-            def read(self, amt=None):
-                if self.closed: return ''
-                return StringIO.read(self, amt)
-            def readline(self, length=None):
-                if self.closed: return ''
-                return StringIO.readline(self, length)
-        class FakeHTTPConnection(HTTPConnection):
-            def connect(self):
-                self.sock = FakeSocket(fakedata)
-        solrconn.conn = FakeHTTPConnection(solrconn.conn.host)
-
-    def test_add(self):
-        output = []
-        c = SolrConnection(host='localhost:8983', persistent=True)
-        self.fakehttp(c, ADD_RESPONSE, output)
-        res = c.add(id='500',name='python test doc')
-
-        output = ''.join(output)
-        self.failUnlessEqual(output, ADD_REQUEST)
-        # Status
-        node = res.findall(".//int")[0]
-        self.failUnlessEqual(node.attrib['name'], 'status')
-        self.failUnlessEqual(node.text, '0')
-        # QTime
-        node = res.findall(".//int")[1]
-        self.failUnlessEqual(node.attrib['name'], 'QTime')
-        self.failUnlessEqual(node.text, '4')
-        res.find('QTime')
-
-    def test_commit(self):
-        output = []
-        c = SolrConnection(host='localhost:8983', persistent=True)
-        self.fakehttp(c, COMMIT_RESPONSE, output)
-        res = c.commit()
-
-        output = ''.join(output)
-        self.failUnlessEqual(output, COMMIT_REQUEST)
-
-        # Status
-        node = res.findall(".//int")[0]
-        self.failUnlessEqual(node.attrib['name'], 'status')
-        self.failUnlessEqual(node.text, '0')
-        # QTime
-        node = res.findall(".//int")[1]
-        self.failUnlessEqual(node.attrib['name'], 'QTime')
-        self.failUnlessEqual(node.text, '55')
-        res.find('QTime')
-
-    def test_search(self):
-        output = []
-        c = SolrConnection(host='localhost:8983', persistent=True)
-        self.fakehttp(c, SEARCH_RESPONSE, output)
-        res = c.search(q='id:[* TO *]', wt='xml', rows='10',indent='on')
-
-        output = ''.join(output)
-        self.failUnlessEqual(output, SEARCH_REQUEST)
-
-        self.failUnless(res.find(('.//doc')))
-
-    def test_delete(self):
-        output = []
-        c = SolrConnection(host='localhost:8983', persistent=True)
-        self.fakehttp(c, DELETE_RESPONSE, output)
-        res = c.delete('500')
-
-        output = ''.join(output)
-        self.failUnlessEqual(output, DELETE_REQUEST)
-
-        # Status
-        node = res.findall(".//int")[0]
-        self.failUnlessEqual(node.attrib['name'], 'status')
-        self.failUnlessEqual(node.text, '0')
-        # QTime
-        node = res.findall(".//int")[1]
-        self.failUnlessEqual(node.attrib['name'], 'QTime')
-        self.failUnlessEqual(node.text, '0')
-        res.find('QTime')
-
-
-class ParserTests(TestCase):
-
-    def testParseSimpleSearchResults(self):
-        response = SolrResponse(SEARCH_RESPONSE.split('\n\n', 1)[1])
-        results = response.response     # the result set is named 'response'
-        match = results[0]
-        self.assertEqual(len(results), 1)
-        self.assertEqual(match.id, '500')
-        self.assertEqual(match.name, 'python test doc')
-        self.assertEqual(match.popularity, 0)
-        self.assertEqual(match.sku, '500')
-        self.assertEqual(match.timestamp, DateTime('2008-02-29 16:11:46.998 GMT'))
-        headers = response.responseHeader
-        self.assertEqual(headers['status'], 0)
-        self.assertEqual(headers['QTime'], 0)
-        self.assertEqual(headers['params']['wt'], 'xml')
-        self.assertEqual(headers['params']['indent'], 'on')
-        self.assertEqual(headers['params']['rows'], '10')
-        self.assertEqual(headers['params']['q'], 'id:[* TO *]')
-
-    def testParseComplexSearchResults(self):
-        response = SolrResponse(COMPLEX_XML_RESPONSE)
-        results = response.response     # the result set is named 'response'
-        self.assertEqual(len(results), 2)
-        first = results[0]
-        self.assertEqual(first.cat, ['software', 'search'])
-        self.assertEqual(len(first.features), 7)
-        self.assertEqual([type(x).__name__ for x in first.features], ['str'] * 6 + ['unicode'])
-        self.assertEqual(first.id, 'SOLR1000')
-        self.assertEqual(first.inStock, True)
-        self.assertEqual(first.incubationdate_dt, DateTime('2006/01/17 GMT'))
-        self.assertEqual(first.manu, 'Apache Software Foundation')
-        self.assertEqual(first.popularity, 10)
-        self.assertEqual(first.price, 0.0)
-        headers = response.responseHeader
-        self.assertEqual(headers['status'], 0)
-        self.assertEqual(headers['QTime'], 0)
-        self.assertEqual(headers['params']['indent'], 'on')
-        self.assertEqual(headers['params']['rows'], '10')
-        self.assertEqual(headers['params']['start'], '0')
-        self.assertEqual(headers['params']['q'], 'id:[* TO *]')
-        self.assertEqual(headers['params']['version'], '2.2')
-
-    def testParseFacetSearchResults(self):
-        response = SolrResponse(FACET_XML_RESPONSE)
-        results = response.response     # the result set is named 'response'
-        self.assertEqual(len(results), 0)
-        headers = response.responseHeader
-        self.assertEqual(type(headers), type({}))
-        self.assertEqual(headers['status'], 0)
-        self.assertEqual(headers['QTime'], 1)
-        self.assertEqual(headers['params']['facet.limit'], '-1')
-        self.assertEqual(headers['params']['rows'], '0')
-        self.assertEqual(headers['params']['facet'], 'true')
-        self.assertEqual(headers['params']['facet.field'], ['cat', 'inStock'])
-        self.assertEqual(headers['params']['indent'], '10')
-        self.assertEqual(headers['params']['q'], 'solr')
-        counts = response.facet_counts
-        self.assertEqual(type(counts), type({}))
-        self.assertEqual(counts['facet_queries'], {})
-        self.assertEqual(counts['facet_fields']['cat']['electronics'], 0)
-        self.assertEqual(counts['facet_fields']['cat']['monitor'], 0)
-        self.assertEqual(counts['facet_fields']['cat']['search'], 1)
-        self.assertEqual(counts['facet_fields']['cat']['software'], 1)
-        self.assertEqual(counts['facet_fields']['inStock']['true'], 1)
-
-    def testParseFacetSearchResults2(self):
-        response = parse2(FACET_XML_RESPONSE)
-        self.failUnless(response)
-        results = response.getResults()
-        self.assertEqual(len(results), 0)
-        headers = response.getHeaders()
-        self.assertEqual(type(headers), type({}))
-        self.assertEqual(headers['status'], 0)
-        self.assertEqual(headers['QTime'], 1)
-        self.assertEqual(headers['params']['facet.limit'], '-1')
-        self.assertEqual(headers['params']['rows'], '0')
-        self.assertEqual(headers['params']['facet'], 'true')
-        self.assertEqual(headers['params']['facet.field'], ['cat', 'inStock'])
-        self.assertEqual(headers['params']['indent'], '10')
-        self.assertEqual(headers['params']['q'], 'solr')
-        counts = response['facet_counts']
-        self.assertEqual(type(counts), type({}))
-        self.assertEqual(counts['facet_queries'], {})
-        self.assertEqual(counts['facet_fields']['cat']['electronics'], 0)
-        self.assertEqual(counts['facet_fields']['cat']['monitor'], 0)
-        self.assertEqual(counts['facet_fields']['cat']['search'], 1)
-        self.assertEqual(counts['facet_fields']['cat']['software'], 1)
-        self.assertEqual(counts['facet_fields']['inStock']['true'], 1)
-
-    def testParseComplexSearchResults2(self):
-        response = parse2(COMPLEX_XML_RESPONSE)
-        self.failUnless(response)
-        results = response.getResults()
-        self.assertEqual(len(results), 2)
-        first = results[0]
-        self.assertEqual(first.cat, ['software', 'search'])
-        self.assertEqual(len(first.features), 7)
-        self.assertEqual([type(x).__name__ for x in first.features], ['str'] * 6 + ['unicode'])
-        self.assertEqual(first.id, 'SOLR1000')
-        self.assertEqual(first.inStock, True)
-        self.assertEqual(first.incubationdate_dt, DateTime('2006/01/17 GMT'))
-        self.assertEqual(first.manu, 'Apache Software Foundation')
-        self.assertEqual(first.popularity, 10)
-        self.assertEqual(first.price, 0.0)
-        headers = response.getHeaders()
-        self.assertEqual(headers['status'], 0)
-        self.assertEqual(headers['QTime'], 0)
-        self.assertEqual(headers['params']['indent'], 'on')
-        self.assertEqual(headers['params']['rows'], '10')
-        self.assertEqual(headers['params']['start'], '0')
-        self.assertEqual(headers['params']['q'], 'id:[* TO *]')
-        self.assertEqual(headers['params']['version'], '2.2')
-
-    def testParseSearchResponse2(self):
-        response = parse2(SEARCH_RESPONSE.split('\n\n', 1)[1])
-        results = response.getResults()
-        match = results[0]
-        self.assertEqual(len(results), 1)
-        self.assertEqual(match.id, '500')
-        self.assertEqual(match.name, 'python test doc')
-        self.assertEqual(match.popularity, 0)
-        self.assertEqual(match.sku, '500')
-        self.assertEqual(match.timestamp, DateTime('2008-02-29 16:11:46.998 GMT'))
-        headers = response.getHeaders()
-        self.assertEqual(headers['status'], 0)
-        self.assertEqual(headers['QTime'], 0)
-        self.assertEqual(headers['params']['wt'], 'xml')
-        self.assertEqual(headers['params']['indent'], 'on')
-        self.assertEqual(headers['params']['rows'], '10')
-        self.assertEqual(headers['params']['q'], 'id:[* TO *]')
-
-    def testParseConfig(self):
-        filename = join(dirname(collective.solr.tests.__file__), 'schema.xml')
-        schema = open(filename, 'r').read()
-        res = parseConfig(schema)
-        self.failUnlessEqual(len(res), 18) # 18 fields defined in schema.xml
-
-
-def test_suite():
-    return TestSuite((
-        makeSuite(TestSolr),
-        makeSuite(ParserTests),
-    ))
-
-if __name__ == '__main__':
-    main(defaultTest='test_suite')
-
Index: collective.solr/trunk/collective/solr/tests/test_parser.py
===================================================================
--- collective.solr/trunk/collective/solr/tests/test_parser.py	(revision 0)
+++ collective.solr/trunk/collective/solr/tests/test_parser.py	(revision 13445)
@@ -0,0 +1,166 @@
+# -*- coding: utf-8 -*-
+
+from unittest import TestCase, TestSuite, makeSuite, main
+from StringIO import StringIO
+from DateTime import DateTime
+from httplib import HTTPConnection
+
+from collective.solr.solr import SolrConnection
+from collective.solr.parser import SolrResponse
+from collective.solr.parser import parse2
+from collective.solr.parser import parseConfig
+from collective.solr.tests.utils import getData
+
+
+class ParserTests(TestCase):
+
+    def testParseSimpleSearchResults(self):
+        search_response = getData('search_response.txt')
+        response = SolrResponse(search_response.split('\n\n', 1)[1])
+        results = response.response     # the result set is named 'response'
+        match = results[0]
+        self.assertEqual(len(results), 1)
+        self.assertEqual(match.id, '500')
+        self.assertEqual(match.name, 'python test doc')
+        self.assertEqual(match.popularity, 0)
+        self.assertEqual(match.sku, '500')
+        self.assertEqual(match.timestamp, DateTime('2008-02-29 16:11:46.998 GMT'))
+        headers = response.responseHeader
+        self.assertEqual(headers['status'], 0)
+        self.assertEqual(headers['QTime'], 0)
+        self.assertEqual(headers['params']['wt'], 'xml')
+        self.assertEqual(headers['params']['indent'], 'on')
+        self.assertEqual(headers['params']['rows'], '10')
+        self.assertEqual(headers['params']['q'], 'id:[* TO *]')
+
+    def testParseComplexSearchResults(self):
+        complex_xml_response = getData('complex_xml_response.txt')
+        response = SolrResponse(complex_xml_response)
+        results = response.response     # the result set is named 'response'
+        self.assertEqual(len(results), 2)
+        first = results[0]
+        self.assertEqual(first.cat, ['software', 'search'])
+        self.assertEqual(len(first.features), 7)
+        self.assertEqual([type(x).__name__ for x in first.features], ['str'] * 6 + ['unicode'])
+        self.assertEqual(first.id, 'SOLR1000')
+        self.assertEqual(first.inStock, True)
+        self.assertEqual(first.incubationdate_dt, DateTime('2006/01/17 GMT'))
+        self.assertEqual(first.manu, 'Apache Software Foundation')
+        self.assertEqual(first.popularity, 10)
+        self.assertEqual(first.price, 0.0)
+        headers = response.responseHeader
+        self.assertEqual(headers['status'], 0)
+        self.assertEqual(headers['QTime'], 0)
+        self.assertEqual(headers['params']['indent'], 'on')
+        self.assertEqual(headers['params']['rows'], '10')
+        self.assertEqual(headers['params']['start'], '0')
+        self.assertEqual(headers['params']['q'], 'id:[* TO *]')
+        self.assertEqual(headers['params']['version'], '2.2')
+
+    def testParseFacetSearchResults(self):
+        facet_xml_response = getData('facet_xml_response.txt')
+        response = SolrResponse(facet_xml_response)
+        results = response.response     # the result set is named 'response'
+        self.assertEqual(len(results), 0)
+        headers = response.responseHeader
+        self.assertEqual(type(headers), type({}))
+        self.assertEqual(headers['status'], 0)
+        self.assertEqual(headers['QTime'], 1)
+        self.assertEqual(headers['params']['facet.limit'], '-1')
+        self.assertEqual(headers['params']['rows'], '0')
+        self.assertEqual(headers['params']['facet'], 'true')
+        self.assertEqual(headers['params']['facet.field'], ['cat', 'inStock'])
+        self.assertEqual(headers['params']['indent'], '10')
+        self.assertEqual(headers['params']['q'], 'solr')
+        counts = response.facet_counts
+        self.assertEqual(type(counts), type({}))
+        self.assertEqual(counts['facet_queries'], {})
+        self.assertEqual(counts['facet_fields']['cat']['electronics'], 0)
+        self.assertEqual(counts['facet_fields']['cat']['monitor'], 0)
+        self.assertEqual(counts['facet_fields']['cat']['search'], 1)
+        self.assertEqual(counts['facet_fields']['cat']['software'], 1)
+        self.assertEqual(counts['facet_fields']['inStock']['true'], 1)
+
+    def testParseFacetSearchResults2(self):
+        facet_xml_response = getData('facet_xml_response.txt')
+        response = parse2(facet_xml_response)
+        self.failUnless(response)
+        results = response.getResults()
+        self.assertEqual(len(results), 0)
+        headers = response.getHeaders()
+        self.assertEqual(type(headers), type({}))
+        self.assertEqual(headers['status'], 0)
+        self.assertEqual(headers['QTime'], 1)
+        self.assertEqual(headers['params']['facet.limit'], '-1')
+        self.assertEqual(headers['params']['rows'], '0')
+        self.assertEqual(headers['params']['facet'], 'true')
+        self.assertEqual(headers['params']['facet.field'], ['cat', 'inStock'])
+        self.assertEqual(headers['params']['indent'], '10')
+        self.assertEqual(headers['params']['q'], 'solr')
+        counts = response['facet_counts']
+        self.assertEqual(type(counts), type({}))
+        self.assertEqual(counts['facet_queries'], {})
+        self.assertEqual(counts['facet_fields']['cat']['electronics'], 0)
+        self.assertEqual(counts['facet_fields']['cat']['monitor'], 0)
+        self.assertEqual(counts['facet_fields']['cat']['search'], 1)
+        self.assertEqual(counts['facet_fields']['cat']['software'], 1)
+        self.assertEqual(counts['facet_fields']['inStock']['true'], 1)
+
+    def testParseComplexSearchResults2(self):
+        complex_xml_response = getData('complex_xml_response.txt')
+        response = parse2(complex_xml_response)
+        self.failUnless(response)
+        results = response.getResults()
+        self.assertEqual(len(results), 2)
+        first = results[0]
+        self.assertEqual(first.cat, ['software', 'search'])
+        self.assertEqual(len(first.features), 7)
+        self.assertEqual([type(x).__name__ for x in first.features], ['str'] * 6 + ['unicode'])
+        self.assertEqual(first.id, 'SOLR1000')
+        self.assertEqual(first.inStock, True)
+        self.assertEqual(first.incubationdate_dt, DateTime('2006/01/17 GMT'))
+        self.assertEqual(first.manu, 'Apache Software Foundation')
+        self.assertEqual(first.popularity, 10)
+        self.assertEqual(first.price, 0.0)
+        headers = response.getHeaders()
+        self.assertEqual(headers['status'], 0)
+        self.assertEqual(headers['QTime'], 0)
+        self.assertEqual(headers['params']['indent'], 'on')
+        self.assertEqual(headers['params']['rows'], '10')
+        self.assertEqual(headers['params']['start'], '0')
+        self.assertEqual(headers['params']['q'], 'id:[* TO *]')
+        self.assertEqual(headers['params']['version'], '2.2')
+
+    def testParseSearchResponse2(self):
+        search_response = getData('search_response.txt')
+        response = parse2(search_response.split('\n\n', 1)[1])
+        results = response.getResults()
+        match = results[0]
+        self.assertEqual(len(results), 1)
+        self.assertEqual(match.id, '500')
+        self.assertEqual(match.name, 'python test doc')
+        self.assertEqual(match.popularity, 0)
+        self.assertEqual(match.sku, '500')
+        self.assertEqual(match.timestamp, DateTime('2008-02-29 16:11:46.998 GMT'))
+        headers = response.getHeaders()
+        self.assertEqual(headers['status'], 0)
+        self.assertEqual(headers['QTime'], 0)
+        self.assertEqual(headers['params']['wt'], 'xml')
+        self.assertEqual(headers['params']['indent'], 'on')
+        self.assertEqual(headers['params']['rows'], '10')
+        self.assertEqual(headers['params']['q'], 'id:[* TO *]')
+
+    def testParseConfig(self):
+        schema = getData('schema.xml')
+        res = parseConfig(schema)
+        self.failUnlessEqual(len(res), 18) # 18 fields defined in schema.xml
+
+
+def test_suite():
+    return TestSuite((
+        makeSuite(ParserTests),
+    ))
+
+if __name__ == '__main__':
+    main(defaultTest='test_suite')
+

Property changes on: collective.solr/trunk/collective/solr/tests/test_parser.py
___________________________________________________________________
Name: svn:eol-style
   + native

Index: collective.solr/trunk/collective/solr/tests/test_solr.py
===================================================================
--- collective.solr/trunk/collective/solr/tests/test_solr.py	(revision 0)
+++ collective.solr/trunk/collective/solr/tests/test_solr.py	(revision 13445)
@@ -0,0 +1,122 @@
+# -*- coding: utf-8 -*-
+
+from os.path import dirname, join
+
+from unittest import TestCase, TestSuite, makeSuite, main
+from StringIO import StringIO
+from DateTime import DateTime
+from httplib import HTTPConnection
+
+import collective.solr.tests
+from collective.solr.solr import SolrConnection
+from collective.solr.parser import SolrResponse
+from collective.solr.parser import parse2
+from collective.solr.parser import parseConfig
+from collective.solr.tests.utils import getData
+
+
+class TestSolr(TestCase):
+
+    def fakehttp(self, solrconn, fakedata, output):
+        class FakeSocket(StringIO):
+            def sendall(self, str): output.append(str)
+            def makefile(self, mode, name): return self
+            def read(self, amt=None):
+                if self.closed: return ''
+                return StringIO.read(self, amt)
+            def readline(self, length=None):
+                if self.closed: return ''
+                return StringIO.readline(self, length)
+        class FakeHTTPConnection(HTTPConnection):
+            def connect(self):
+                self.sock = FakeSocket(fakedata)
+        solrconn.conn = FakeHTTPConnection(solrconn.conn.host)
+
+    def test_add(self):
+        add_request = getData('add_request.txt')
+        add_response = getData('add_response.txt')
+        output = []
+
+        c = SolrConnection(host='localhost:8983', persistent=True)
+        self.fakehttp(c, add_response, output)
+        res = c.add(id='500',name='python test doc')
+
+        output = ''.join(output).replace('\r','')
+        self.failUnlessEqual(output, add_request)
+        # Status
+        node = res.findall(".//int")[0]
+        self.failUnlessEqual(node.attrib['name'], 'status')
+        self.failUnlessEqual(node.text, '0')
+        # QTime
+        node = res.findall(".//int")[1]
+        self.failUnlessEqual(node.attrib['name'], 'QTime')
+        self.failUnlessEqual(node.text, '4')
+        res.find('QTime')
+
+    def test_commit(self):
+        commit_request = getData('commit_request.txt')
+        commit_response = getData('commit_response.txt')
+        output = []
+
+        c = SolrConnection(host='localhost:8983', persistent=True)
+        self.fakehttp(c, commit_response, output)
+        res = c.commit()
+
+        output = ''.join(output).replace('\r','')
+        self.failUnlessEqual(output, commit_request)
+
+        # Status
+        node = res.findall(".//int")[0]
+        self.failUnlessEqual(node.attrib['name'], 'status')
+        self.failUnlessEqual(node.text, '0')
+        # QTime
+        node = res.findall(".//int")[1]
+        self.failUnlessEqual(node.attrib['name'], 'QTime')
+        self.failUnlessEqual(node.text, '55')
+        res.find('QTime')
+
+    def test_search(self):
+        search_request = getData('search_request.txt')
+        search_response = getData('search_response.txt')
+        output = []
+
+        c = SolrConnection(host='localhost:8983', persistent=True)
+        self.fakehttp(c, search_response, output)
+        res = c.search(q='id:[* TO *]', wt='xml', rows='10',indent='on')
+
+        output = ''.join(output).replace('\r','')
+        self.failUnlessEqual(output, search_request)
+
+        self.failUnless(res.find(('.//doc')))
+
+    def test_delete(self):
+        delete_request = getData('delete_request.txt')
+        delete_response = getData('delete_response.txt')
+        output = []
+
+        c = SolrConnection(host='localhost:8983', persistent=True)
+        self.fakehttp(c, delete_response, output)
+        res = c.delete('500')
+
+        output = ''.join(output).replace('\r','')
+        self.failUnlessEqual(output, delete_request)
+
+        # Status
+        node = res.findall(".//int")[0]
+        self.failUnlessEqual(node.attrib['name'], 'status')
+        self.failUnlessEqual(node.text, '0')
+        # QTime
+        node = res.findall(".//int")[1]
+        self.failUnlessEqual(node.attrib['name'], 'QTime')
+        self.failUnlessEqual(node.text, '0')
+        res.find('QTime')
+
+
+def test_suite():
+    return TestSuite((
+        makeSuite(TestSolr),
+    ))
+
+if __name__ == '__main__':
+    main(defaultTest='test_suite')
+

Property changes on: collective.solr/trunk/collective/solr/tests/test_solr.py
___________________________________________________________________
Name: svn:eol-style
   + native

Index: collective.solr/trunk/collective/solr/tests/__init__.py
===================================================================
--- collective.solr/trunk/collective/solr/tests/__init__.py	(revision 0)
+++ collective.solr/trunk/collective/solr/tests/__init__.py	(revision 13445)
@@ -0,0 +1 @@
+# module
\ No newline at end of file

Property changes on: collective.solr/trunk/collective/solr/tests/__init__.py
___________________________________________________________________
Name: svn:eol-style
   + native

Index: collective.solr/trunk/collective/solr/tests/utils.py
===================================================================
--- collective.solr/trunk/collective/solr/tests/utils.py	(revision 0)
+++ collective.solr/trunk/collective/solr/tests/utils.py	(revision 13445)
@@ -0,0 +1,7 @@
+from os.path import dirname, join
+import collective.solr.tests
+
+def getData(filename):
+    """Return file as string"""
+    filename = join(dirname(collective.solr.tests.__file__), 'data', filename)
+    return open(filename, 'r').read()

Property changes on: collective.solr/trunk/collective/solr/tests/utils.py
___________________________________________________________________
Name: svn:eol-style
   + native

Index: collective.solr/trunk/collective/solr/tests/data/schema.xml
===================================================================
--- collective.solr/trunk/collective/solr/tests/data/schema.xml	(revision 0)
+++ collective.solr/trunk/collective/solr/tests/data/schema.xml	(revision 13445)
@@ -0,0 +1,111 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<schema name="example" version="1.1">
+  <types>
+    <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
+    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true" omitNorms="true"/>
+    <fieldType name="integer" class="solr.IntField" omitNorms="true"/>
+    <fieldType name="long" class="solr.LongField" omitNorms="true"/>
+    <fieldType name="float" class="solr.FloatField" omitNorms="true"/>
+    <fieldType name="double" class="solr.DoubleField" omitNorms="true"/>
+    <fieldType name="sint" class="solr.SortableIntField" sortMissingLast="true" omitNorms="true"/>
+    <fieldType name="slong" class="solr.SortableLongField" sortMissingLast="true" omitNorms="true"/>
+    <fieldType name="sfloat" class="solr.SortableFloatField" sortMissingLast="true" omitNorms="true"/>
+    <fieldType name="sdouble" class="solr.SortableDoubleField" sortMissingLast="true" omitNorms="true"/>
+    <fieldType name="date" class="solr.DateField" sortMissingLast="true" omitNorms="true"/>
+    <fieldType name="random" class="solr.RandomSortField" indexed="true"/>
+    <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
+      <analyzer>
+        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      </analyzer>
+    </fieldType>
+    <fieldType name="text" class="solr.TextField" positionIncrementGap="100">
+      <analyzer type="index">
+        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
+        <filter class="solr.LowerCaseFilterFactory"/>
+        <filter class="solr.EnglishPorterFilterFactory" protected="protwords.txt"/>
+        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+      </analyzer>
+      <analyzer type="query">
+        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
+        <filter class="solr.LowerCaseFilterFactory"/>
+        <filter class="solr.EnglishPorterFilterFactory" protected="protwords.txt"/>
+        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+      </analyzer>
+    </fieldType>
+    <fieldType name="textTight" class="solr.TextField" positionIncrementGap="100">
+      <analyzer>
+        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
+        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
+        <filter class="solr.LowerCaseFilterFactory"/>
+        <filter class="solr.EnglishPorterFilterFactory" protected="protwords.txt"/>
+        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+      </analyzer>
+    </fieldType>
+    <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
+      <analyzer>
+        <tokenizer class="solr.KeywordTokenizerFactory"/>
+        <filter class="solr.LowerCaseFilterFactory"/>
+        <filter class="solr.TrimFilterFactory"/>
+        <filter class="solr.PatternReplaceFilterFactory" pattern="([^a-z])" replacement="" replace="all"/>
+      </analyzer>
+    </fieldType>
+    <fieldtype name="ignored" stored="false" indexed="false" class="solr.StrField"/> 
+ </types>
+ <fields>
+   <field name="id" type="string" indexed="true" stored="true" required="true"/> 
+   <field name="sku" type="textTight" indexed="true" stored="true" omitNorms="true"/>
+   <field name="name" type="text" indexed="true" stored="true"/>
+   <field name="nameSort" type="string" indexed="true" stored="false"/>
+   <field name="alphaNameSort" type="alphaOnlySort" indexed="true" stored="false"/>
+   <field name="manu" type="text" indexed="true" stored="true" omitNorms="true"/>
+   <field name="cat" type="text_ws" indexed="true" stored="true" multiValued="true" omitNorms="true" termVectors="true"/>
+   <field name="features" type="text" indexed="true" stored="true" multiValued="true"/>
+   <field name="includes" type="text" indexed="true" stored="true"/>
+   <field name="weight" type="sfloat" indexed="true" stored="true"/>
+   <field name="price" type="sfloat" indexed="true" stored="true"/>
+   <field name="popularity" type="sint" indexed="true" stored="true" default="0"/>
+   <field name="inStock" type="boolean" indexed="true" stored="true"/>
+   <field name="word" type="string" indexed="true" stored="true"/>
+   <field name="text" type="text" indexed="true" stored="false" multiValued="true"/>
+   <field name="manu_exact" type="string" indexed="true" stored="false"/>
+   <field name="timestamp" type="date" indexed="true" stored="true" default="NOW" multiValued="false"/>
+
+   <!-- Dynamic field definitions.  If a field name is not found, dynamicFields
+        will be used if the name matches any of the patterns.
+        RESTRICTION: the glob-like pattern in the name attribute must have
+        a "*" only at the start or the end.
+        EXAMPLE:  name="*_i" will match any field ending in _i (like myid_i, z_i)
+        Longer patterns will be matched first.  if equal size patterns
+        both match, the first appearing in the schema will be used.  -->
+   <dynamicField name="*_i" type="sint" indexed="true" stored="true"/>
+   <dynamicField name="*_s" type="string" indexed="true" stored="true"/>
+   <dynamicField name="*_l" type="slong" indexed="true" stored="true"/>
+   <dynamicField name="*_t" type="text" indexed="true" stored="true"/>
+   <dynamicField name="*_b" type="boolean" indexed="true" stored="true"/>
+   <dynamicField name="*_f" type="sfloat" indexed="true" stored="true"/>
+   <dynamicField name="*_d" type="sdouble" indexed="true" stored="true"/>
+   <dynamicField name="*_dt" type="date" indexed="true" stored="true"/>
+
+   <dynamicField name="random*" type="random"/>
+ </fields>
+ <uniqueKey>id</uniqueKey>
+ <defaultSearchField>text</defaultSearchField>
+ <solrQueryParser defaultOperator="OR"/>
+   <copyField source="id" dest="sku"/>
+   <copyField source="incubationdate_dt" dest="incubationdate_s"/>
+   <copyField source="cat" dest="text"/>
+   <copyField source="name" dest="text"/>
+   <copyField source="name" dest="nameSort"/>
+   <copyField source="name" dest="alphaNameSort"/>
+   <copyField source="manu" dest="text"/>
+   <copyField source="features" dest="text"/>
+   <copyField source="includes" dest="text"/>
+   <copyField source="manu" dest="manu_exact"/>
+</schema>
\ No newline at end of file
Index: collective.solr/trunk/collective/solr/tests/data/search_response.txt
===================================================================
--- collective.solr/trunk/collective/solr/tests/data/search_response.txt	(revision 0)
+++ collective.solr/trunk/collective/solr/tests/data/search_response.txt	(revision 13445)
@@ -0,0 +1,29 @@
+HTTP/1.1 200 OK
+Content-Type: text/xml; charset=utf-8
+Content-Length: 560
+Server: Jetty(6.1.3)
+
+<?xml version="1.0" encoding="UTF-8"?>
+<response>
+
+<lst name="responseHeader">
+ <int name="status">0</int>
+ <int name="QTime">0</int>
+ <lst name="params">
+  <str name="wt">xml</str>
+  <str name="indent">on</str>
+  <str name="rows">10</str>
+  <str name="q">id:[* TO *]</str>
+ </lst>
+</lst>
+<result name="response" numFound="1" start="0">
+ <doc>
+  <str name="id">500</str>
+  <str name="name">python test doc</str>
+  <int name="popularity">0</int>
+  <str name="sku">500</str>
+  <date name="timestamp">2008-02-29T16:11:46.998Z</date>
+ </doc>
+</result>
+</response>
+

Property changes on: collective.solr/trunk/collective/solr/tests/data/search_response.txt
___________________________________________________________________
Name: svn:eol-style
   + native

Index: collective.solr/trunk/collective/solr/tests/data/complex_xml_response.txt
===================================================================
--- collective.solr/trunk/collective/solr/tests/data/complex_xml_response.txt	(revision 0)
+++ collective.solr/trunk/collective/solr/tests/data/complex_xml_response.txt	(revision 13445)
@@ -0,0 +1,51 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<response>
+
+<lst name="responseHeader">
+ <int name="status">0</int>
+ <int name="QTime">0</int>
+ <lst name="params">
+  <str name="indent">on</str>
+  <str name="rows">10</str>
+
+  <str name="start">0</str>
+  <str name="q">id:[* TO *]</str>
+  <str name="version">2.2</str>
+ </lst>
+</lst>
+<result name="response" numFound="2" start="0">
+ <doc>
+  <arr name="cat"><str>software</str><str>search</str></arr>
+
+  <arr name="features"><str>Advanced Full-Text Search Capabilities using Lucene</str><str>Optimizied for High Volume Web Traffic</str><str>Standards Based Open Interfaces - XML and HTTP</str>
+	<str>Comprehensive HTML Administration Interfaces</str><str>Scalability - Efficient Replication to other Solr Search Servers</str><str>Flexible and Adaptable with XML configuration and Schema</str><str>Good unicode support: héllo (hello with an accent over the e)</str></arr>
+  <str name="id">SOLR1000</str>
+  <bool name="inStock">true</bool>
+
+  <date name="incubationdate_dt">2006-01-17T00:00:00.000Z</date>
+  <str name="manu">Apache Software Foundation</str>
+  <str name="name">Solr, the Enterprise Search Server</str>
+  <int name="popularity">10</int>
+  <float name="price">0.0</float>
+  <str name="sku">SOLR1000</str>
+
+  <date name="timestamp">2008-03-01T00:13:11.767Z</date>
+ </doc>
+ <doc>
+  <arr name="cat"><str>electronics</str><str>monitor</str></arr>
+  <arr name="features"><str>30" TFT active matrix LCD, 2560 x 1600, .25mm dot pitch, 700:1 contrast</str></arr>
+  <str name="id">3007WFP</str>
+
+  <bool name="inStock">true</bool>
+  <str name="includes">USB cable</str>
+  <str name="manu">Dell, Inc.</str>
+  <str name="name">Dell Widescreen UltraSharp 3007WFP</str>
+  <int name="popularity">6</int>
+  <float name="price">2199.0</float>
+
+  <str name="sku">3007WFP</str>
+  <date name="timestamp">2008-03-01T00:13:11.814Z</date>
+  <float name="weight">401.6</float>
+ </doc>
+</result>
+</response>

Property changes on: collective.solr/trunk/collective/solr/tests/data/complex_xml_response.txt
___________________________________________________________________
Name: svn:eol-style
   + native

Index: collective.solr/trunk/collective/solr/tests/data/add_response.txt
===================================================================
--- collective.solr/trunk/collective/solr/tests/data/add_response.txt	(revision 0)
+++ collective.solr/trunk/collective/solr/tests/data/add_response.txt	(revision 13445)
@@ -0,0 +1,10 @@
+HTTP/1.1 200 OK
+Content-Type: text/xml; charset=utf-8
+Content-Length: 147
+Server: Jetty(6.1.3)
+
+<?xml version="1.0" encoding="UTF-8"?>
+<response>
+<lst name="responseHeader"><int name="status">0</int><int name="QTime">4</int></lst>
+</response>
+

Property changes on: collective.solr/trunk/collective/solr/tests/data/add_response.txt
___________________________________________________________________
Name: svn:eol-style
   + native

Index: collective.solr/trunk/collective/solr/tests/data/commit_response.txt
===================================================================
--- collective.solr/trunk/collective/solr/tests/data/commit_response.txt	(revision 0)
+++ collective.solr/trunk/collective/solr/tests/data/commit_response.txt	(revision 13445)
@@ -0,0 +1,10 @@
+HTTP/1.1 200 OK
+Content-Type: text/xml; charset=utf-8
+Content-Length: 148
+Server: Jetty(6.1.3)
+
+<?xml version="1.0" encoding="UTF-8"?>
+<response>
+<lst name="responseHeader"><int name="status">0</int><int name="QTime">55</int></lst>
+</response>
+

Property changes on: collective.solr/trunk/collective/solr/tests/data/commit_response.txt
___________________________________________________________________
Name: svn:eol-style
   + native

Index: collective.solr/trunk/collective/solr/tests/data/delete_request.txt
===================================================================
--- collective.solr/trunk/collective/solr/tests/data/delete_request.txt	(revision 0)
+++ collective.solr/trunk/collective/solr/tests/data/delete_request.txt	(revision 13445)
@@ -0,0 +1,7 @@
+POST /solr/update HTTP/1.1
+Host: localhost
+Accept-Encoding: identity
+Content-Length: 29
+Content-Type: text/xml; charset=utf-8
+
+<delete><id>500</id></delete>
\ No newline at end of file

Property changes on: collective.solr/trunk/collective/solr/tests/data/delete_request.txt
___________________________________________________________________
Name: svn:eol-style
   + native

Index: collective.solr/trunk/collective/solr/tests/data/search_request.txt
===================================================================
--- collective.solr/trunk/collective/solr/tests/data/search_request.txt	(revision 0)
+++ collective.solr/trunk/collective/solr/tests/data/search_request.txt	(revision 13445)
@@ -0,0 +1,7 @@
+POST /solr/select HTTP/1.1
+Host: localhost
+Accept-Encoding: identity
+Content-Length: 48
+Content-Type: application/x-www-form-urlencoded; charset=utf-8
+
+q=id%3A%5B%2A+TO+%2A%5D&rows=10&wt=xml&indent=on
\ No newline at end of file

Property changes on: collective.solr/trunk/collective/solr/tests/data/search_request.txt
___________________________________________________________________
Name: svn:eol-style
   + native

Index: collective.solr/trunk/collective/solr/tests/data/add_request.txt
===================================================================
--- collective.solr/trunk/collective/solr/tests/data/add_request.txt	(revision 0)
+++ collective.solr/trunk/collective/solr/tests/data/add_request.txt	(revision 13445)
@@ -0,0 +1,7 @@
+POST /solr/update HTTP/1.1
+Host: localhost
+Accept-Encoding: identity
+Content-Length: 92
+Content-Type: text/xml; charset=utf-8
+
+<add><doc><field name="id">500</field><field name="name">python test doc</field></doc></add>
\ No newline at end of file

Property changes on: collective.solr/trunk/collective/solr/tests/data/add_request.txt
___________________________________________________________________
Name: svn:eol-style
   + native

Index: collective.solr/trunk/collective/solr/tests/data/commit_request.txt
===================================================================
--- collective.solr/trunk/collective/solr/tests/data/commit_request.txt	(revision 0)
+++ collective.solr/trunk/collective/solr/tests/data/commit_request.txt	(revision 13445)
@@ -0,0 +1,7 @@
+POST /solr/update HTTP/1.1
+Host: localhost
+Accept-Encoding: identity
+Content-Length: 9
+Content-Type: text/xml; charset=utf-8
+
+<commit/>
\ No newline at end of file

Property changes on: collective.solr/trunk/collective/solr/tests/data/commit_request.txt
___________________________________________________________________
Name: svn:eol-style
   + native

Index: collective.solr/trunk/collective/solr/tests/data/delete_response.txt
===================================================================
--- collective.solr/trunk/collective/solr/tests/data/delete_response.txt	(revision 0)
+++ collective.solr/trunk/collective/solr/tests/data/delete_response.txt	(revision 13445)
@@ -0,0 +1,10 @@
+HTTP/1.1 200 OK
+Content-Type: text/xml; charset=utf-8
+Content-Length: 147
+Server: Jetty(6.1.3)
+
+<?xml version="1.0" encoding="UTF-8"?>
+<response>
+<lst name="responseHeader"><int name="status">0</int><int name="QTime">0</int></lst>
+</response>
+

Property changes on: collective.solr/trunk/collective/solr/tests/data/delete_response.txt
___________________________________________________________________
Name: svn:eol-style
   + native

Index: collective.solr/trunk/collective/solr/tests/data/facet_xml_response.txt
===================================================================
--- collective.solr/trunk/collective/solr/tests/data/facet_xml_response.txt	(revision 0)
+++ collective.solr/trunk/collective/solr/tests/data/facet_xml_response.txt	(revision 13445)
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<response>
+
+<lst name="responseHeader">
+ <int name="status">0</int>
+ <int name="QTime">1</int>
+ <lst name="params">
+  <str name="facet.limit">-1</str>
+  <str name="rows">0</str>
+
+  <str name="facet">true</str>
+  <arr name="facet.field">
+	<str>cat</str>
+	<str>inStock</str>
+  </arr>
+  <str name="indent">10</str>
+  <str name="q">solr</str>
+
+ </lst>
+</lst>
+<result name="response" numFound="1" start="0"/>
+<lst name="facet_counts">
+ <lst name="facet_queries"/>
+ <lst name="facet_fields">
+  <lst name="cat">
+	<int name="electronics">0</int>
+	<int name="monitor">0</int>
+
+	<int name="search">1</int>
+	<int name="software">1</int>
+  </lst>
+  <lst name="inStock">
+	<int name="true">1</int>
+  </lst>
+ </lst>
+
+</lst>
+</response>

Property changes on: collective.solr/trunk/collective/solr/tests/data/facet_xml_response.txt
___________________________________________________________________
Name: svn:eol-style
   + native

