Index: collective.solr/trunk/collective/solr/parser.py
===================================================================
--- collective.solr/trunk/collective/solr/parser.py	(revision 13433)
+++ collective.solr/trunk/collective/solr/parser.py	(revision 13434)
@@ -1,8 +1,10 @@
 from elementtree.ElementTree import iterparse
 from StringIO import StringIO
 from DateTime import DateTime
+from types import ListType, DictType
 
 
+# unmarshallers for basic types
 unmarshallers = {
     'int': lambda x: int(x.text),
     'float': lambda x: float(x.text),
@@ -11,6 +13,15 @@
     'date': lambda x: DateTime(x.text),
 }
 
+def setter(item, name, value):
+    """ sets the named value on item respecting its type """
+    if type(item) == ListType:
+        item.append(value)      # name is ignored for lists
+    elif type(item) == DictType:
+        item[name] = value
+    else:                       # object is assumed...
+        setattr(item, name, value)
+
 
 class SolrFlare(object):
     """ a sol(a)r brain; TODO: this should get an interface!! """
@@ -19,6 +30,14 @@
 class SolrResponse(object):
     """ a solr search response; TODO: this should get an interface!! """
 
+    # nesting tags along with their factories
+    nested = {
+        'arr': lambda: [],
+        'lst': lambda: {},
+        'result': lambda: [],
+        'doc': SolrFlare,
+    }
+
     def __init__(self, data=None):
         if data is not None:
             self.parse(data)
@@ -27,76 +46,22 @@
         """ parse a solr response contained in a string or file-like object """
         if isinstance(data, basestring):
             data = StringIO(data)
+        nested = self.nested.has_key
+        stack = [self]
         elements = iterparse(data, events=('start', 'end'))
         for action, elem in elements:
+            tag = elem.tag
             if action == 'start':
-                if elem.tag == 'result':
-                    results = self.parseResults(elem, elements)
-                    setattr(self, elem.get('name'), results)
-                elif elem.tag == 'lst':
-                    info = self.parseListing(elem, elements)
-                    setattr(self, elem.get('name'), info)
-
-    def parseResults(self, elem, elements):
-        """ sub-parser for solr search results """
-        results = []
-        flare = None
-        array = None
-        for action, elem in elements:
-            if action == 'start':
-                if elem.tag == 'doc':   # start of result, create brain...
-                    flare = SolrFlare()
-                    results.append(flare)
-                elif flare is not None:
-                    if elem.tag == 'arr':   # start of array, set it up...
-                        array = []
-                        setattr(flare, elem.get('name'), array)
-                    else:
-                        unmarshal = unmarshallers.get(elem.tag)
-                        if unmarshal is not None:   # known type?
-                            data = unmarshal(elem)
-                            if array is not None:   # array element
-                                array.append(data)
-                            else:                   # regular attribute
-                                setattr(flare, elem.get('name'), data)
-            elif action == 'end':
-                if elem.tag == 'arr':   # end of array, "close" it
-                    array = None
-                elif elem.tag == 'result':  # end of results, return!
-                    break
-        return results
-
-    def parseListing(self, elem, elements):
-        """ sub-parser for solr search information """
-        lst = {}
-        stack = [lst]
-        array = None
-        for action, elem in elements:
-            if action == 'start':
-                if elem.tag == 'lst':   # start of nested dictionary
-                    lst = {}
-                    stack.append(lst)
-                elif elem.tag == 'arr':   # start of array, set it up...
-                    array = []
-                    lst[elem.get('name')] = array
-                else:
-                    unmarshal = unmarshallers.get(elem.tag)
-                    if unmarshal is not None:   # known type?
-                        data = unmarshal(elem)
-                        if array is not None:   # array element
-                            array.append(data)
-                        else:                   # dictionary key/value
-                            lst[elem.get('name')] = data
+                if nested(tag):
+                    stack.append(self.nested[tag]())
+                elif unmarshallers.has_key(tag):
+                    data = unmarshallers[tag](elem)
+                    setter(stack[-1], elem.get('name'), data)
             elif action == 'end':
-                if elem.tag == 'arr':   # end of array, "close" it
-                    array = None
-                elif elem.tag == 'lst': # end of nested dictionary
-                    top = stack.pop()
-                    if not stack:
-                        break
-                    lst = stack[-1]
-                    lst[elem.get('name')] = top
-        return lst
+                if nested(tag):
+                    data = stack.pop()
+                    setter(stack[-1], elem.get('name'), data)
+        return self
 
 
 # Traditional parser style
